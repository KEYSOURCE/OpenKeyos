<?php

class_load ('Computer');
class_load ('DiscoverySetting');
class_load ('DiscoverySettingDetail');
class_load ('SnmpSysobjid');

/** Class for representing devices found by network discoveries
*
* This class will store the devices discovered by Kawacs Agent, when instructed to
* do so through DiscoverySetting and DiscoverySettingDetail.
*
* Where possible, the system will try to automatically match the discovered devices 
* to Keyos devices. For computers this is done by name and/or MAC. For other
* devices, the system will try to find matches by name (which in most cases will 
* fail though) and by IP address, for peripherals/AD printers which are monitored
* by SNMP (and for which, therefore, the IP address is known).
*
* When you have a discovered device which does not need to be matched in Keyos,
* it can be flagged as such ('Not in Keyos' option).
*
* There are devices for which no proper identification strings are available,
* meaning all of the following fields are empty: host_name, nb_name, mac and nb_mac.
* If such devices are not manually flagged as using fixed IPs, when a discovery is
* reported all such previously discovered devices are deleted prior to placing the
* new discovery results in the database.
*
* There are two types of notifications which can be triggered by discoveries. First
* there are customer-specific notifications raised when there are devices without
* Keyos matches and which have not been flagged as 'Not in Keyos'.
*
* Then there are computers notifications raised when a computer is discovered but
* the matching Keyos computer has a much older 'last_contact' date - which indicated
* that although the computer is active (since it was found in discovery), it has
* not sent any reports through Kawacs Agent recently.
* 
*/

class Discovery extends Base
{
	/** The unique object ID
	* @var int */
	var $id = null;
	
	/** The ID of the DiscoverySettingDetail object from which triggered the discovery 
	* @var int */
	var $detail_id = null;
	
	/** The last time when the device was discovered
	* @var timestamp */
	var $last_discovered = 0;
	
	/** True if this IP address is flagged as being a fixed IP address
	* @var bool */
	var $is_fixed_ip = false;
	
	/** True or False if the discovered device was matched automatically or not to 
	* a Keyos object, if a match has been done at all
	* @var bool */
	var $matched_auto = false;
	
	/** The type of the Keyos object matched for this device - see $GLOBALS['SNMP_OBJ_CLASSES']
	* @var int */
	var $matched_obj_class = 0;
	
	/** The ID of the Keyos object matched for this device. If empty, there is no matched object
	* If -1, this means this device will not exist in Keyos.
	* @var int */
	var $matched_obj_id = 0;
	
	// The following fields are the values reported by the Kawacs Agent
	
	/** The IP address on which the device was discovered
	* @var string */
	var $ip = '';
	
	/** True or False if the discovery process was finished ok by Kawacs Agent for this device
	* @var bool */
	var $finished_ok = false;
	
	/** The duration of the discovery for this device, in seconds
	* @var float */
	var $duration = 0;
	
	/** The steps made by the Kawacs Agent during the discovery, useful for debugging
	* @var text */
	var $steps = '';
	
	/** The MAC address of the device. Note that even if the device has multiple 
	* interfaces, only one is reported (the one on which the device was contacted)
	* IMPORTANT NOTE: In the case of computers connected over VPN, the MAC address shown
	* here is dynamically generated by the VPN server, so it is not always safe for
	* identifying computers.
	* @var string */
	var $mac = '';
	
	/** The host name of the device obtain with by KawacsAgent with GetHostByAddr - can be DNS name or Netbios name
	* @var string */
	var $host_name = '';
	
	/** The Netbios name of the device
	* @var string */
	var $nb_name = '';
	
	/** The Netbios workgroup of the device
	* @var string */
	var $nb_workgroup = '';
	
	/** The mac address of the device obtained from Netbios
	* @var string */
	var $nb_mac = '';
	
	/** True or False if the device responded to SNMP queries
	* @var bool */
	var $snmp_resp = false;
	
	/** The SNMP object id for the device, which can be used for identifying the device type
	* @var string */
	var $snmp_sys_object_id = '';
	
	/** The SNMP device name - usually the Netbios name
	* @var string */
	var $snmp_sys_name = '';
	
	/** The SNMP device description 
	* @var string */
	var $snmp_sys_desc = '';
	
	/** Ths SNMP contact info for the device
	* @var string */
	var $snmp_sys_contact = '';
	
	/** True or False if the device responded or not to WMI queries
	* @var bool */
	var $wmi_resp = false;
	
	/** The SNMP error message, if any errors were encountered during WMI contact
	* @var string */
	var $wmi_error = '';
	
	/** The WMI device type
	* @var string */
	var $wmi_system_type = '';
	
	/** The WMI device description
	* @var string */
	var $wmi_description = '';
	
	/** The domain to which the device belongs
	* @var string */
	var $wmi_domain = '';
	
	/** The role of the device in the domain - see $GLOBALS['WMI_DOMAIN_ROLES']
	* @var int */
	var $wmi_domain_role = 0;
	
	/** The manufacturer name from WMI
	* @var string */
	var $wmi_manufacturer = '';
	
	/** The device model name from WMI
	* @var string */
	var $wmi_model = '';
	
	/** The device name from WMI - usually the Netbios name
	* @var string */
	var $wmi_name = '';
	
	/** The amount of device memory, in bytes
	* @var int */
	var $wmi_total_phys_memory = 0;
	
	/** The current logged in user
	* @var string */
	var $wmi_user_name = '';
	
	/** A name or description provided by the OEM manufacturer
	* @var string */
	var $wmi_oem_string_array = '';
	
	/** The owner contact from WMI
	* @var string */
	var $wmi_primary_owner_contact = '';
	
	/** The name of the device owner from WMI
	* @var string */
	var $wmi_primary_owner_name = '';
	
	/** The OS name from WMI
	* @var string */
	var $wmi_os_caption = '';
	
	/** The OS organization from WMI
	* @var string */
	var $wmi_os_organization = '';
	
	/** The OS serial number from WMI
	* @var string */
	var $wmi_os_serial_number = '';
	
	/** The OS service pack from WMI
	* @var string */
	var $wmi_os_csd_verion = '';
	
	
	/** The name of the Keyos object matched for this device. 
	* @var string */
	var $matched_obj_name = '';
	
	/** The URL to the Keyos object matched for this device
	* @var string */
	var $matched_obj_url = '';
	
	/** The descriptive name associated with the object's SNMP system object id, if any
	* @var string */
	var $snmp_sys_object_name = '';

	
	/** The database table storing objects data 
	* @var string */
	var $table = TBL_DISCOVERIES;
	
	/** List of fields to be used when fetching or saving data to the database
	* @var array */
	var $fields = array('id','detail_id', 'last_discovered', 'is_fixed_ip', 'matched_auto', 'matched_obj_class', 'matched_obj_id',
		'ip', 'finished_ok', 'duration', 'steps', 'mac', 'host_name', 'nb_name', 'nb_workgroup', 'nb_mac',
		'snmp_resp', 'snmp_sys_object_id', 'snmp_sys_name', 'snmp_sys_desc', 'snmp_sys_contact',
		'wmi_resp', 'wmi_error', 'wmi_system_type', 'wmi_description', 'wmi_domain', 'wmi_domain_role', 'wmi_manufacturer', 'wmi_model', 'wmi_name',
		'wmi_total_phys_memory', 'wmi_user_name', 'wmi_oem_string_array', 'wmi_primary_owner_contact', 'wmi_primary_owner_name',
		'wmi_os_caption', 'wmi_os_organization', 'wmi_os_serial_number', 'wmi_os_csd_version');
		
	/** List of fields to be used when loading reported data into the object 
	* @var array */
	var $fields_reporting = array('detail_id', 'ip', 'finished_ok', 'duration', 'steps', 'mac', 'host_name', 'nb_name', 'nb_workgroup', 'nb_mac',
		'snmp_resp', 'snmp_sys_object_id', 'snmp_sys_name', 'snmp_sys_desc', 'snmp_sys_contact',
		'wmi_resp', 'wmi_error', 'wmi_system_type', 'wmi_description', 'wmi_domain', 'wmi_domain_role', 'wmi_manufacturer', 'wmi_model', 'wmi_name',
		'wmi_total_phys_memory', 'wmi_user_name', 'wmi_oem_string_array', 'wmi_primary_owner_contact', 'wmi_primary_owner_name',
		'wmi_os_caption', 'wmi_os_organization', 'wmi_os_serial_number', 'wmi_os_csd_version');
	
		
		
	/** Constructor. Also load an object from the database if an ID is specified */
	function Discovery ($id = null)
	{
		if ($id)
		{
			$this->id = $id;
			$this->load_data ();
		}
	}
	
	/** Loads the object data, as well as the name of the matched object - if any */
	function load_data ()
	{
		parent::load_data ();
		if ($this->matched_obj_id > 0)
		{
			// We need to manually load BaseDisplay in case this part of code is executed in a SOAP or crontab call
			class_display_load ('base');  
			 
			// Load the name of the matched object
			switch ($this->matched_obj_class)
			{
				case SNMP_OBJ_CLASS_COMPUTER:
					$q = 'SELECT netbios_name FROM '.TBL_COMPUTERS.' WHERE id='.$this->matched_obj_id;
					$this->matched_obj_name = '#'.$this->matched_obj_id.': '.db::db_fetch_field ($q, 'netbios_name');
					$this->matched_obj_url = BaseDisplay::mk_redir ('computer_view', array('id'=>$this->matched_obj_id), 'kawacs');
					break;
				case SNMP_OBJ_CLASS_PERIPHERAL:
					$q = 'SELECT name FROM '.TBL_PERIPHERALS.' WHERE id='.$this->matched_obj_id;
					$this->matched_obj_name = db::db_fetch_field ($q, 'name');
					$this->matched_obj_url = BaseDisplay::mk_redir ('peripheral_edit', array('id'=>$this->matched_obj_id), 'kawacs');
					break;
				case SNMP_OBJ_CLASS_AD_PRINTER:
					$q = 'SELECT canonical_name FROM '.TBL_AD_PRINTERS_EXTRAS.' WHERE id='.$this->matched_obj_id;
					$this->matched_obj_name = preg_replace ('/.*\//', '', db::db_fetch_field($q, 'canonical_name'));
					$this->matched_obj_url = BaseDisplay::mk_redir ('ad_printer_view', array('id'=>$this->matched_obj_id), 'kerm');
					break;
			}
		}
		if ($this->snmp_sys_object_id) $this->snmp_sys_object_name = SnmpSysobjid::get_name ($this->snmp_sys_object_id);
		else $this->snmp_sys_object_name = '';
	}
	
	/** Checks if the object data is valid */
	function is_valid_data ()
	{
		$ret = true;
		
		if (!$this->is_identifiable() and $this->matched_obj_id != 0)
		{
			$ret = false; 
			error_msg ($this->get_string('MATCH_NEEDS_IDENTIFIABLE'));
		}
		
		return $ret;
	}
	
	/** Saves object data, also setting the discovery time if it wasn't set already */
	function save_data ()
	{
		if (!$this->last_discovered) $this->last_discovered = time ();
		parent::save_data ();
	}
	
	/** Loads into the object a set of reported data. It is similar with load_from_array, but it makes sure that
	* all fields which are filled from reported info are initialized, so there is no obsolete data from previous
	* reports */
	function load_reported_data ($data)
	{
		if (is_array($data))
		{
			foreach ($this->fields_reporting as $field)
			{
				if (isset($data[$field])) $this->$field = $data[$field];
				else $this->$field = '';
			}
		}
	}
	
	/** Returns true or false if this is an identifiable device, meaning if at least one of
	* the following fields set: nb_name, host_name, mac or nb_mac, or must be specified to have 
	* a fixed IP. */
	function is_identifiable ()
	{
		return ($this->nb_name or $this->host_name or $this->mac or $this->nb_mac or $this->is_fixed_ip);
	}
	
	
	/** [Class Method] Returns the discoveries which have been matched with the specified computer ID
	* @param	int			$computer_id		The ID of the computer
	* @return	array(Discovery)				Array with the matched Discovery objects, if any
	*/
	public static function get_matches_for_computer ($computer_id)
	{
		$ret = array ();
		
		if ($computer_id)
		{
			$q = 'SELECT id FROM '.TBL_DISCOVERIES.' WHERE matched_obj_class='.SNMP_OBJ_CLASS_COMPUTER.' AND matched_obj_id='.$computer_id.' ';
			$q.= 'ORDER BY last_discovered DESC, id';
			$ids = DB::db_fetch_vector ($q);
			foreach ($ids as $id) $ret[] = new Discovery ($id);
		}
		
		return $ret;
	}
	
	/** [Class Method] Returns the discoveries which have been matched with the specified peripheral ID
	* @param	int			$peripheral_id		The ID of the peripheral
	* @return	array(Discovery)				Array with the matched Discovery objects, if any
	*/
	public static function get_matches_for_peripheral ($peripheral_id)
	{
		$ret = array ();
		
		if ($peripheral_id)
		{
			$q = 'SELECT id FROM '.TBL_DISCOVERIES.' WHERE matched_obj_class='.SNMP_OBJ_CLASS_PERIPHERAL.' AND matched_obj_id='.$peripheral_id.' ';
			$q.= 'ORDER BY last_discovered DESC, id';
			$ids = DB::db_fetch_vector ($q);
			foreach ($ids as $id) $ret[] = new Discovery ($id);
		}
		
		return $ret;
	}
	
	/** [Class Method] Returns the discoveries which have been matched with the specified AD Printer
	* @param	int			$ad_printer_id		The ID of the AD Printer
	* @return	array(Discovery)				Array with the matched Discovery objects, if any
	*/
	public static function get_matches_for_ad_printer ($ad_printer_id)
	{
		$ret = array ();
		
		if ($ad_printer_id)
		{
			$q = 'SELECT id FROM '.TBL_DISCOVERIES.' WHERE matched_obj_class='.SNMP_OBJ_CLASS_AD_PRINTER.' AND matched_obj_id='.$ad_printer_id.' ';
			$q.= 'ORDER BY last_discovered DESC, id';
			$ids = DB::db_fetch_vector ($q);
			foreach ($ids as $id) $ret[] = new Discovery ($id);
		}
		
		return $ret;
	}
	
	/** [Class Method] Deletes from the database, for a specific DiscoverySettingDetail ID, all devices 
	* which don't have any identification string (nb_name, host_name, mac or nb_mac) and which are 
	* not marked as using a fixed IP. This is usually invoked when a new discovery is reported by 
	* Kawcs Agent, prior to processing the reported discovery data
	* @param	int			$detail_id 		The ID of the DiscoverySettingDetail ID for which 
	*								the reported data is processed
	*/
	public static function clear_unidentifiable_devices ($detail_id)
	{
		if ($detail_id)
		{
			$q = 'DELETE FROM '.TBL_DISCOVERIES.' WHERE detail_id='.$detail_id.' AND ';
			$q.= 'is_fixed_ip=0 AND host_name="" AND nb_name="" AND mac="" AND nb_mac=""';
			DB::db_query ($q);
		}
	}
	
	
	/** [Class Method] Checks if a given Discovery object exists in a given list of Discovery objects. 
	* This can be used for checking if a reported discovered device is new or not.
	* A series of checks is performed and a final match is considered to have been found when one of
	* the checks returns a match. The checks done, in order, are: nb_name, host_name, mac, nb_mac, ip
	* If more than 1 match is found, the first encountered match is returned
	* NOTE: No check is done with the objects IDs
	* @param	Discovery		$discovery		(By reference) The Discovery object to look for
	* @param	array(Discovery)	$discoveries		(By reference) Array with the discoveries objects to look in
	* @return	int						The ID of the found Discovery object, or 0 if no match is found
	*/
	public static function getExistingId (&$discovery, &$discoveries)
	{
		$ret = 0;
		
		if (is_array($discoveries))
		{
			$i_max = count($discoveries);
			$matches = 0;
			$matches_mac = array ();
			$matches_nb_mac = array ();
			$matches_nb_name = array ();
			$matches_host_name = array ();
			
			// Try the IP address - but only those which are flagged as being fixed IPs
			if ($matches != 1 and $discovery->ip)
			{
				$matches = 0;
				for ($i=0; $i<$i_max; $i++) if ($discoveries[$i]->ip == $discovery->ip and $discoveries[$i]->is_fixed_ip)
				{
					$ret = $discoveries[$i]->id;
					$matches++;
				}
				if ($matches == 1) return $ret;
			}
			
			// Try the Netbios names
			if ($matches != 1 and $discovery->nb_name)
			{
				$matches = 0;
				for ($i=0; $i<$i_max; $i++) if ($discoveries[$i]->nb_name == $discovery->nb_name)
				{
					$ret = $discoveries[$i]->id;
					$matches_nb_name[] = $i;
					$matches++;
				}
				if ($matches == 1) return $ret;
			}
			
			// Try the host names
			if ($matches != 1 and $discovery->host_name)
			{
				$matches = 0;
				for ($i=0; $i<$i_max; $i++) if ($discoveries[$i]->host_name == $discovery->host_name)
				{
					$ret = $discoveries[$i]->id;
					$matches_host_name[] = $i;
					$matches++;
				}
				if ($matches == 1) return $ret;
			}
			
			// Try the MAC addresses
			if ($matches != 1 and $discovery->mac)
			{
				$matches = 0;
				for ($i=0; $i < $i_max; $i++) if ($discoveries[$i]->mac == $discovery->mac)
				{
					$ret = $discoveries[$i]->id;
					$matches_mac[] = $i;
					$matches++;
				}
				if ($matches == 1) return $ret;
			}
			
			// Try also the Netbios reported MACs
			if ($matches != 1 and $discovery->nb_mac)
			{
				$matches = 0;
				for ($i=0; $i<$i_max; $i++) if ($discoveries[$i]->nb_mac == $discovery->nb_mac)
				{
					$ret = $discoveries[$i]->id;
					$matches_nb_mac[] = $i;
					$matches++;
				}
				if ($matches == 1) return $ret;
			}
			
			
			
			// If we got to this point, none of the tests returned exactly one match
			// So check if we have anywhere more than 1 match and return the first value from there.
			// In case of matching names, for more safety check if any of the matching names also match on MAC
			if (count($matches_nb_name) > 1)
			{
				if (!$discovery->mac and !$discovery->nb_mac) return $discoveries[$matches_nb_name[0]]->id;
				else
				{
					foreach ($matches_nb_name as $idx)
					{
						if ($discovery->mac and $discovery->mac==$discoveries[$idx]->mac) return $discoveries[$matches_nb_name[0]]->id;
						if ($discovery->nb_mac and $discovery->nb_mac==$discoveries[$idx]->nb_mac) return $discoveries[$matches_nb_name[0]]->id;
					}
					return $discoveries[$matches_nb_name[0]]->id;
				}
			}
			if (count($matches_host_name) > 1) 
			{
				if (!$discovery->mac and !$discovery->nb_mac) return $discoveries[$matches_host_name[0]]->id;
				else
				{
					foreach ($matches_host_name as $idx)
					{
						if ($discovery->mac and $discovery->mac==$discoveries[$idx]->mac) return $discoveries[$matches_host_name[0]]->id;
						if ($discovery->nb_mac and $discovery->nb_mac==$discoveries[$idx]->nb_mac) return $discoveries[$matches_host_name[0]]->id;
					}
					return $discoveries[$matches_host_name[0]]->id;
				}
			}
			if (count($matches_mac) > 1) return $discoveries[$matches_mac[0]]->id;
			if (count($matches_nb_mac) > 1) return $discoveries[$matches_nb_mac[0]]->id;
		}
		
		return $ret;
	}
	
	/** Returns the MAC address for this device, either the main 'mac' field or the Netbios discovered MAC.
	* If they differ (although normally should not be the case) the main mac has priority. If only one
	* is defined, that one will be returned.
	*/
	function get_mac ()
	{
		$ret = '';
		
		if ($this->mac) $ret = $this->mac;
		else $ret = $this->nb_mac;
		
		return $ret;
	}
	
	/** Returns the computer name, depending on which fields are filled in. The preference order is:
	* nb_name, host_name, snmp_sys_name
	*/
	function get_name ()
	{
		if ($this->nb_name) $ret = $this->nb_name;
		elseif ($this->host_name) $ret = $this->host_name;
		elseif ($this->snmp_sys_name) $ret = $this->snmp_sys_name;
		else $ret = '';
		return $ret;
	}
	
	
	/** If the object has a matched Keyos computer, returns True or False if the computer's last
	* Kawacs Agent contact is older than the last discovery date with more than DISCOVERY_REPORTING_ISSUE_INTERVAL seconds
	*/
	function is_computer_late_reporting ()
	{
		$ret = false;
		if ($this->id and $this->matched_obj_class==SNMP_OBJ_CLASS_COMPUTER and $this->matched_obj_id > 0)
		{
			$q = 'SELECT last_contact FROM '.TBL_COMPUTERS.' WHERE id='.$this->matched_obj_id;
			$last_contact = db::db_fetch_field ($q, 'last_contact');
			if ($last_contact)
			{
				$ret = $this->last_discovered > ($last_contact + DISCOVERY_REPORTING_ISSUE_INTERVAL);
			}
		}
		return $ret;
	}
	
	/** Sets the matching Keyos object for this discovered devices. Note that this
	* method does NOT save the object to the database.
	* @param	int			$obj_class	The object class of the match
	* @param	int			$obj_id		The object ID
	* @param	bool			$is_auto	True or False if this was an automatic or manual assignment.
	*							NOTE: if the object class and object ID are the same as they
	*							were already in the object, the parameter is ignored.
	*							
	*/
	function set_matched_object ($obj_class, $obj_id, $is_auto = false)
	{
		if ($this->matched_obj_class!=$obj_class or $this->matched_obj_id!=$obj_id)
		{
			$this->matched_auto = $is_auto;
		}
		$this->matched_obj_class = $obj_class;
		$this->matched_obj_id = $obj_id;
	}
	
	
	/** Finds mathing Keyos devices for this discovered device. There are two modes to call this, identified by the
	* $strict_mode parameter.
	* If True, then the function will only attempt to match devices by their NetBIOS names only, or, if that fails,
	* will also check in peripherals to see if any SNMP monitored peripheral/AD Printer is assigned to that IP.
	* If False, it will check all matching possibilities, including names and MAC addresses matches.
	* The first option is normally used from computer reporting, for trying to auto-match newly discovered devices.
	* @param	bool			$strict_mode	If to do a strict matching or not.
	* @param	int			$customer_id	(Optional) The ID of the customer for which the matching is done. If it is not
	*							specified, then it will be loaded from the database.
	* @return	array					Array of associative arrays with the matched Keyos
	*							devices. Each associative array has two fields: 'obj_class' and 'obj_id'
	*/
	function get_keyos_matches ($strict_mode, $customer_id = null)
	{
		$ret = array ();
		if ($this->matched_obj_id >= 0 or !$strict_mode)
		{
		
			// Load the customer ID if is not specified
			if (!$customer_id)
			{
				$customer_id = db::db_fetch_field ('SELECT customer_id FROM '.TBL_DISCOVERIES_SETTINGS_DETAILS.' WHERE id='.$this->detail_id, 'customer_id');
			}
			// Will store the ids of the matching devices
			$ids_comp = array ();
			$ids_periph = array ();
			$ids_ad_printers = array ();
			
			// First do the strict checks
			// See if there is any computer with this NetBIOS name or host name
			if ($this->nb_name)
			{
				$q = 'SELECT id FROM '.TBL_COMPUTERS.' WHERE customer_id='.$customer_id.' AND netbios_name="'.db::db_escape($this->nb_name).'"';
				$ids_comp = db::db_fetch_vector ($q);
			}
			if ($this->host_name and (count($ids_comp)==0 or !$strict_mode))
			{
				$q = 'SELECT id FROM '.TBL_COMPUTERS.' WHERE customer_id='.$customer_id.' AND netbios_name="'.db::db_escape($this->host_name).'"';
				$ids = db::db_fetch_vector ($q);
				foreach ($ids as $id) if (!in_array($id, $ids_comp)) $ids_comp[] = $id;
			}
			
			// If no matching computer is found, check if there are any SNMP monitored peripherals on the specified IP
			if (count($ids_comp)==0 and $this->ip)
			{
				class_load ('Mib');
				$devs_periph = Mib::get_snmp_devices (array('customer_id'=>$customer_id, 'snmp_ip'=>$this->ip, 'obj_class'=>SNMP_OBJ_CLASS_PERIPHERAL));
				if (is_array($devs_periph[$customer_id][SNMP_OBJ_CLASS_PERIPHERAL]))
				{
					foreach ($devs_periph[$customer_id][SNMP_OBJ_CLASS_PERIPHERAL] as $obj) $ids_periph[] = $obj['obj_id'];
				}
				$devs_ad_printers = Mib::get_snmp_devices (array('customer_id'=>$customer_id, 'snmp_ip'=>$this->ip, 'obj_class'=>SNMP_OBJ_CLASS_AD_PRINTER));
				if (is_array($devs_ad_printers[$customer_id][SNMP_OBJ_CLASS_AD_PRINTER]))
				{
					foreach ($devs_ad_printers[$customer_id][SNMP_OBJ_CLASS_AD_PRINTER] as $obj) $ids_ad_printers[] = $obj['obj_id'];
				}
			}
			
			// If this is not a strict search, do additional checks
			if (!$strict_mode)
			{
				// See if we can match computers by MAC
				$mac = $this->get_mac ();
				if ($mac and !is_bogus_mac($mac))
				{
					// Search for matching computers by looking at all reported MAC address in all network cards reported items
					// There is no point in also looking in the computers table, because the MAC addresses from there should always
					// exist in the reported items as well
					$q = 'SELECT ci.computer_id FROM '.TBL_COMPUTERS_ITEMS.' ci INNER JOIN '.TBL_COMPUTERS.' c ';
					$q.= 'ON ci.computer_id=c.id AND c.customer_id='.$customer_id.' ';
					$q.= 'WHERE item_id='.NET_ADAPTERS_ITEM_ID.' AND field_id='.FIELD_ID_NET_MAC.' AND ';
					$q.= 'value="'.$mac.'" ORDER BY c.netbios_name';
					$ids = db::db_fetch_vector ($q);
					foreach ($ids as $id) if (!in_array($id, $ids_comp)) $ids_comp[] = $id;
				}
				
				// See if we can match peripherals by name. No point in looking at AD printers names,
				// because in Keyos we only have AD data, which doesn't contain the NetBios name.
				$name = $this->get_name ();
				if ($name)
				{
					$q = 'SELECT id FROM '.TBL_PERIPHERALS.' WHERE customer_id='.$customer_id.' AND name="'.db::db_escape($name).'"';
					$ids = db::db_fetch_vector ($q);
					foreach ($ids as $id) if (!in_array($id, $ids_periph)) $ids_periph[] = $id;
				}
			}
			
			// Compose the final result
			foreach ($ids_comp as $id) $ret[] = array ('obj_class' => SNMP_OBJ_CLASS_COMPUTER, 'obj_id' => $id);
			foreach ($ids_periph as $id) $ret[] = array ('obj_class' => SNMP_OBJ_CLASS_PERIPHERAL, 'obj_id' => $id);
			foreach ($ids_ad_printers as $id) $ret[] = array ('obj_class' => SNMP_OBJ_CLASS_AD_PRINTER, 'obj_id' => $id);
			
			//echo "$this->nb_name :: $this->host_name :: $this->ip";
			//debug ($ret);
			
		}
		return $ret;
	}
	
	
	/** [Class Method] Sorts an array of Discovery objects properly by their IP addresses 
	* @param	array(Discovery)		$discoveries		(By reference) The array to sort
	*/
	public static function sort_by_ips (&$discoveries)
	{
		if (is_array($discoveries)) usort ($discoveries, array('Discovery', 'cmp_ips'));
	}
	
	
	/** [Class Method] Compares two Discovery objects by their IPs, used for usort(). If IPs are the same, sort by names (nb_name first) */
	public static function cmp_ips ($a, $b)
	{
		$a_num = ip2long($a->ip);
		$b_num = ip2long($b->ip);
		if ($a_num == $b_num)
		{
			if ($a->nb_name == $b->nb_name)
			{
				if ($a->host_name == $b->host_name) return 0;
				return ($a->host_name > $b->host_name ? 1 : -1);
			}
			return ($a->nb_name > $b->nb_name ? 1 : -1);
		}
		return ($a_num > $b_num ? 1 : -1);
	}
	
	/** [Class Method] Compares two Discovery objects by their names, as given by get_name(). Can be used for usort() */
	public static function cmp_names ($a, $b)
	{
		$a_name = strtolower($a->get_name ());
		$b_name = strtolower($b->get_name ());
		if ($a_name == $b_name) return self::cmp_ips ($a, $b);
		return ($a_name > $b_name ? 1 : -1);
	}
	
	/** [Class Method] Returns found discoveries according to some criteria
	* @param	int			$customer_id		The ID of the customer for which to return the discoveries
	* @param	array			$filter			Associative array with filtering criteria. Can contain:
	*								- detail_id: Return only discoveries for the given DiscoverySettingDetail ID
	*								- order_by: Can be 'ip' (default), 'name', 'last_discovered', 'last_discovered_desc' or 'duration'
	*								- match: Can be:
	*								  - 1: Only devices with Keyos matches
	*								  - 2: Only devices without Keyos matches
	*								  - 3: Only devices "not in Keyos"
	*/
	public static function get_discoveries ($customer_id, $filter = array ())
	{
		$ret = array ();
		
		if ($customer_id)
		{
			$q = 'SELECT d.id FROM '.TBL_DISCOVERIES.' d INNER JOIN '.TBL_DISCOVERIES_SETTINGS_DETAILS.' dsd ';
			$q.= 'ON d.detail_id=dsd.id AND dsd.customer_id='.$customer_id.' WHERE ';
			if ($filter['detail_id']) $q.= 'd.detail_id='.$filter['detail_id'].' AND ';
			
			if ($filter['match']==1) $q.= 'matched_obj_id > 0 AND ';
			elseif ($filter['match']==2) $q.= 'matched_obj_id = 0 AND ';
			elseif ($filter['match']==3) $q.= 'matched_obj_id < 0 AND ';
			
			$q = preg_replace ('/AND\s*$/', '', $q);
			$q = preg_replace ('/WHERE\s*$/', '', $q);
			
			if ($filter['order_by']=='name') $q.= 'ORDER BY nb_name, host_name, ip';
			elseif ($filter['order_by']=='last_discovered') $q.= 'ORDER BY last_discovered, nb_name, host_name, ip';
			elseif ($filter['order_by']=='last_discovered_desc') $q.= 'ORDER BY last_discovered DESC, nb_name, host_name, ip';
			elseif ($filter['order_by']=='duration') $q.= 'ORDER BY d.duration DESC, nb_name, host_name, ip';
			
			$ids = DB::db_fetch_vector ($q);
			foreach ($ids as $id) $ret[] = new Discovery($id);
			
			if (!$filter['order_by'] or $filter['order_by']=='ip') Discovery::sort_by_ips ($ret);
			elseif ($filter['order_by'] == 'name') usort($ret, array('Discovery', 'cmp_names'));
		}
		
		return $ret;
	}
	
	/** [Class Method] Returns the total number of discovered devices for a customer */
	public static function get_customer_devices_count ($customer_id)
	{
		$ret = 0;
		
		if ($customer_id)
		{
			$q = 'SELECT count(*) as cnt FROM '.TBL_DISCOVERIES.' d INNER JOIN '.TBL_DISCOVERIES_SETTINGS_DETAILS.' dd ';
			$q.= 'ON d.detail_id=dd.id AND dd.customer_id='.$customer_id;
			$ret = DB::db_fetch_field ($q, 'cnt');
		}
		
		return $ret;
	}
	
	/** [Class Method] Returns True or False if for the specified customer there are discovered devices
	* which are not matched to Keyos objects (or are not specified as "Matched in Keyos") */
	public static function has_unmatched_discoveries ($customer_id)
	{
		$ret = false;
		
		if ($customer_id)
		{
			$q = 'SELECT d.id FROM '.TBL_DISCOVERIES.' d INNER JOIN '.TBL_DISCOVERIES_SETTINGS_DETAILS.' dd ';
			$q.= 'ON d.detail_id=dd.id AND dd.customer_id='.$customer_id.' WHERE d.matched_obj_id=0 LIMIT 1';
			
			if (DB::db_fetch_field ($q, 'id')) $ret = true;
		}
		
		return $ret;
	}
	
	
	/** [Class Method] Returns the IDs of all active customers which have discovered devices withou Keyos matches */
	public static function get_customers_without_matches ()
	{
		$ret = array ();
		
		$q = 'SELECT DISTINCT dd.customer_id FROM '.TBL_DISCOVERIES.' d INNER JOIN '.TBL_DISCOVERIES_SETTINGS_DETAILS.' dd ';
		$q.= 'ON d.detail_id=dd.id INNER JOIN '.TBL_CUSTOMERS.' c ON dd.customer_id=c.id AND c.active=1 ';
		$q.= 'ORDER BY c.name ';
		$ret = DB::db_fetch_vector ($q);
		
		return $ret;
	}
	
	
	/** [Class Method] Returns all computers which have matching discoveries, but which have not reported through
	* Kawacs Agent in a while. This normally means that the respective computers exist and are running (since they
	* were found in discoveries) but it might be something wrong with the Kawacs Agent.
	* NOTE: These checks are done only for active customers and computers which are not blacked out.
	* @param	bool			$load_objects		Specifies if to load and return the found objects (True) or if
	*								to return only the IDs of the affected computers (False)
	* @return	array						If $load_objects is True, returns and array of associative arrays 
	*								with the found computers.
	*								Each associative array has the fields:
	*								- computer: the associated Computer object
	*								- discovery: the associated Discovery object
	*								- detail: the associated DiscoverySettingDetail object
	*								  from which the discovery was made.
	*								If $load_objects is False, returns an array with the IDs of the
	*								problem computers.
	*/
	public static function get_non_reporting_computers ($load_objects = true)
	{
		$ret = array ();
		
		$q = 'SELECT d.id, d.detail_id, d.matched_obj_id FROM '.TBL_DISCOVERIES.' d INNER JOIN '.TBL_COMPUTERS.' c ';
		$q.= 'ON d.matched_obj_class='.SNMP_OBJ_CLASS_COMPUTER.' AND d.matched_obj_id=c.id AND c.last_contact>0 ';
		$q.= 'INNER JOIN '.TBL_CUSTOMERS.' cust ON c.customer_id=cust.id AND cust.active=1 ';
		$q.= 'LEFT OUTER JOIN '.TBL_COMPUTERS_BLACKOUTS.' b ON c.id=b.computer_id ';
		$q.= 'WHERE d.last_discovered>c.last_contact+'.DISCOVERY_REPORTING_ISSUE_INTERVAL.' AND b.computer_id IS NULL';
		
		$data = DB::db_fetch_array ($q);
		if ($load_objects)
		{
			foreach ($data as $d)
			{
				$ret[] = array (
					'computer' => new Computer ($d->matched_obj_id),
					'discovery' => new Discovery ($d->id),
					'detail' => new DiscoverySettingDetail ($d->detail_id)
				);
			}
		}
		else
		{
			foreach ($data as $d) $ret[] = $d->matched_obj_id;
		}
		
		return $ret;
	}

}

?>