<?php

/**
* Class for making and working with HTTP connection, including connections
* using Digest authentication.
*
* 
*/

class HttpConn 
{
	/** The server (IP address or machine) to which to connect to
	* @var string */
	var $server = '';
	
	/** HTTP connection method to use
	* @var string */
	var $method = 'GET';
	
	/** The port on server on which to connect
	* @var int */
	var $port = 80;
	
	/** The protocol to user (HTTP or HTTPS)
	* @var string */
	var $protocol = 'HTTPS';
	
	/** The URL to which to connect to 
	* @var string */
	var $url = '/';
	
	/** The body of the HTTP request to send
	* @var string */
	var $payload = '';
	
	/** The type of payload/content - used for the Content-Type HTTP header
	* @var string */
	var $content_type = '';
	
	/** The last error message encountered, if any
	* @var string */
	var $last_error = '';
	
	/** Associative array with the HTTP headers to send, the keys being 
	* HTTP header names and the values being their respective values to send
	* @var array */
	var $headers = array ();
	
	/** Additional headers requested to be set by the calling application 
	* @var array */
	var $headers_extra = array ();
	
	/** Associative array with the cookies received or to send to the server
	* @var array */
	var $cookies = array ();
	
	
	/** The socket for communicating with the server
	* @var handle */
	var $fp = null;
	
	/** True or False if a connection with the server has been established
	* @var bool */
	var $is_connected = false;
	
	/** The socket timeout (seconds)
	* @var int */
	var $timeout = 5; //xxxxxxxxxx
	
	/** Last encountered connection error number (from fsockopen())
	* @var int */
	var $last_conn_errno = 0;
	
	/** Last encountered connection error message (from fsockopen())
	* @var string */
	var $last_conn_errstr = '';
	
	
	/** The authentication type to use: Basic or Digest
	* @var string */
	var $auth_type = 'Basic';
	
	/** The username for authenticated connections
	* @var string */
	var $username = '';
	
	/** The password for authenticated connections
	* NOTE: Once a connection to the server is tried, regardless of the outcome,
	* the password is cleared from the object, so the object can be safely saved,
	* e.g. saved in session variables.
	* For succesfull Digest authentications, the H(A1) value will be stored instead,
	* in the digest_ha1 field.
	* @var string */
	var $password = '';
	
	
	/** The line with response status received from server
	* @var string */
	var $resp_status = '';
	
	/** The response status code received from server
	* @var int */
	var $resp_status_code = '';
	
	/** The response status message received from server
	* @var string */
	var $resp_status_msg = '';
	
	/** The HTTP response headers received from server. They are stored as 
	* a progressive array, each element containing an associative array with two keys: 'name' and 'value'.
	* This representation is needed because in the response header there might be multiple lines
	* for the same type of header, e.g. multiple WWW-Authenticate lines
	* @var array */
	var $resp_headers = array ();
	
	/** The size of the content given by server - if any
	* @var int */
	var $resp_content_length = 0;
	
	/** True or False if the response header has "Transfer-Encoding: chunked", which
	* means that the response will have to be read in parts
	* @var boolean */
	var $resp_chunked = false;
	
	
	/** For Basic authentication: the Base64 encoding of the username/password
	* @var string */
	var $basic_ident = '';
	
	
	/** For Digest authentication: the QOP parameter received from server
	* @var string */
	var $digest_qop = '';
	
	/** For Digest authentication: the hashing method requested by server (MD5 or MD5-sess)
	* @var string */
	var $digest_algorithm = '';
	
	/** For Digest authentication: the NONCE parameter received from server
	* @var string */
	var $digest_nonce = '';
	
	/** For Digest authentication: the authentication realm received from server
	* @var string */
	var $digest_realm = '';
	
	/** For Digest authentication: the CNONCE parametered generated by the client (this)
	* @var string */
	var $digest_cnonce = '';
	
	/** For Digest authentication: the counter of uses of the same NONCE parameter
	* @var string */
	var $digest_counter = 0;
	
	/** For Digest authentication: the H(A1) value, meaning MD5(login:realm:password)
	* @var string */
	var $digest_ha1 = '';
	
	
	/** Constructor. Initializes an object for connecting to a given URL on a specified server */
	function HttpConn ($server, $url = '/', $method = 'GET', $port = 80, $protocol = 'HTTP')
	{
		$this->server = $server;
		$this->url = $url;
		$this->method = $method;
		$this->port = $port;
		$this->protocol = strtoupper ($protocol);
	}
	
	
	/** Prepares the object to make a new request to a new URL */
	function set_new_url ($url, $method = 'GET', $payload = '', $content_type = 'text/html')
	{
		$this->url = $url;
		$this->method = $method;
		$this->payload = $payload;
		$this->content_type = $content_type;
		$this->last_error = '';
		
		$this->headers = array ();
		$this->header_extra = array ();
		$this->resp_headers = array ();
		$this->last_conn_errno = 0;
		$this->last_conn_errstr = '';
		
		$this->resp_status_code = '';
		$this->resp_status_msg = '';
		
		// Make sure we are not already connected
		$this->do_disconnect ();
	}
	
	
	/** Set credentials using a login name and a password */
	function set_credentials_password ($username, $password)
	{
		$this->username = $username;
		$this->password = $password;
		$this->digest_ha1 = '';
		$this->basic_ident = base64_encode ($username.':'.$password);
	}
	
	/** Set credentials using a login name and an already existing hash H(A1) needed for digest authentication. */
	function set_credentials_hash ($username, $ha1)
	{
		$this->username = $username;
		$this->password = '';
		$this->digest_ha1 = $ha1;
	}
	
	/** Set credentials for Basic authentication. */
	function set_credentials_basic ($username, $basic_ident)
	{
		$this->username = $username;
		$this->password = '';
		$this->basic_ident = $basic_ident;
	}
	
	/** Place into the object the request body to send, if needed */
	function set_payload ($payload, $content_type = 'text/html')
	{
		$this->payload = $payload;
		$this->content_type = $content_type;
	}
	
	
	/** Performs a login on the Exchange server, using the credential provided earlier, either with
	* set_credentials_password() or set_credentials_hash().
	* Will send first a non-authenticated request to the server, to which the server will respond with
	* a 401 and with the NONCE, realm and encoding values needed to build a digest authentication
	* request.
	* NOTE: Regardless of the result of the authentication, the password field is always made empty
	* in this procedure, in case the object will be stored somewhere unsafe (e.g. in the session)
	* @param	string				$response 	(By reference) Will be loaded with the response body received
	*								from the server - e.g. the payload could have been loaded with
	*								a request for fetching additional user info from the server.
	* @param	array				$extra_headers	Associative array with extra headers to add to the
	*								HTTP request.
	* @return	boolean						True or False if the authentication was succesfull or not.
	*/
	function do_authentication (&$response, $extra_headers = array ())
	{
		$ret = false;
		$this->headers_extra = $extra_headers;
		$this->set_default_headers ();
		
		// Clear the settings for digest authentication
		$this->digest_qop = '';
		$this->digest_algorithm = '';
		$this->digest_nonce = '';
		$this->digest_realm = '';
		$this->digest_counter = 0;
		
		if ($this->do_connect())
		{
			// Send the initial request
			$this->send_request ();
			$response = $this->read_response ();
			$this->do_disconnect ();
			
			if ($this->resp_status_code >= '200' and $this->resp_status_code < '300')
			{
				// An authenticated connection has been established, no need to do further processing
				$ret = true;
			}
			else
			{
				// There is a connection problem
				if ($this->resp_status_code) $this->last_error = '('.$this->resp_status_code.') '.$this->resp_status_msg;
				elseif (!$this->last_error) $this->last_error = 'Failure in communication with Exchange server.';
				$ret = false;
			}
		}
		
		// Whatever the result, clear the password field - just in case the object is saved in session
		// or somewhere else unsafe
		$this->password = '';
		
		return $ret;
	}
	
	
	/** Read the server response. It automatically makes a reading of the HTTP response headers using
	* the read_headers() method.
	* @return	string						The body of the HTTP response from the server
	*/
	function read_response ()
	{
		$ret = '';
		if ($this->fp)
		{
			if ($this->read_headers())
			{
				// Read the response body
				if (!$this->resp_chunked)
				{
					if ($this->resp_content_length) $ret = fread($this->fp, $this->resp_content_length);
					else while ($s = fread ($this->fp, 1024)) $ret.= $s;
				}
				else
				{
					// This is a "Transfer-Encoding: chunked" response, must read in parts
					do
					{
					
						$chunk_size = hexdec(fgets($this->fp));
						
						//echo "$chunk_size<br>";
						if($chunk_size > 0)
							$ret.= fread ($this->fp, $chunk_size);
					} while ($chunk_size > 0);
					
					//for ($i=0; $i<10; $i++) echo "<br>XX: " .htmlentities(fgets($this->fp, 1024));
				}
			}
			//debug ($this->resp_headers);
			//echo  htmlentities($ret); die;
		}
		return $ret;
	}
	
	
	/** Parse the headers received from the server and load the corresponding values in the object fields */
	function parse_received_headers ($response_headers)
	{
		$this->resp_status = -1;
		$this->resp_status_msg = '';
		$this->resp_headers = array ();
		$this->resp_chunked = false;
		$this->resp_content_length = 0;
	
		// Break the header into lines
		$response_header_lines = preg_split ('/\r\n|\n/', $response_headers);
	
		$s = $response_header_lines[0];
		$this->resp_status = trim ($s);
		$s = preg_replace ('/^HTTP\/1\.[01]\s*/', '', $s);
		list ($this->resp_status_code, $this->resp_status_msg) = preg_split ('/\s+/', $s, 2);
		$this->resp_status_msg = trim ($this->resp_status_msg);
		
		foreach ($response_header_lines as $s)
		{
			list($k, $v) = preg_split ('/\:/', $s, 2);
			$k = trim ($k);
			$v = trim ($v);
			
			$this->resp_headers[] = array ('name'=>$k, 'value'=>$v);
			if ($k == 'Set-Cookie') $this->parse_resp_cookies ($s);
			elseif ($k == 'Content-Length') $this->resp_content_length = intval($v);
			elseif ($k == 'Transfer-Encoding' and $v == 'chunked') $this->resp_chunked = true;
		}
		
		$this->parse_received_headers_auth ();
	}
	
	
	/** Loads from the response headers into the object the values for digest and basic authentication */
	function parse_received_headers_auth ()
	{
		// Parse headers for digest authentication
		$auth_head = $this->get_resp_headers ('WWW-Authenticate', '^Digest');
		if (count($auth_head) > 0)
		{
			$digest = preg_replace ('/^Digest\s*/', '', $auth_head[0]);
			$digest_vals = preg_split ('/,\s*/', $digest);
			$digest_params = array ();
			foreach ($digest_vals as $s)
			{
				list ($k, $v) = preg_split ('/\=\s*/', $s);
				$digest_params[trim($k)] = trim(preg_replace('/\"/', '', $v));
			}
			$this->digest_qop = $digest_params['qop'];
			$this->digest_algorithm = $digest_params['algorithm'];
			$this->digest_nonce = $digest_params['nonce'];
			$this->digest_realm = $digest_params['realm'];
			
		
			// Build the digest authentication request
			if (!$this->digest_cnonce)
			{
				// This is the first time when authentication is done
				$this->digest_counter = 1;
				$this->digest_cnonce = md5(time());
				
				// We might have a password, in which case the authentication needs to be initialized, or
				// we migh have the SHA1 string already.
				if ($this->password)
				{
					$this->digest_ha1 = md5($this->username.':'.$this->digest_realm.':'.$this->password);
				}
			}
		}
		
		// Parse headers for basic authentication
		$auth_head = $this->get_resp_headers ('WWW-Authenticate');//, '^Basic');
		
		if (count($auth_head) > 0 and $this->username and $this->password)
		{
			$this->basic_ident = base64_encode ($this->username.':'.$this->password);
		}
	}
	
	/** Read the response HTTP headers from the server and places them in the $this->resp_headers field.
	* While the heders are read, the fields resp_content_length, cookies, resp_status_msg and resp_status_code
	* are also loaded (if they are present in the response header).
	* If the server returns a 401 and we already have a NONCE value, then the function will attempt to 
	* re-connect because the 401 response could simply mean that the server wants us to use a new NONCE.
	* @return	mixed						For HTTP: True or False if reading the headers was OK.
	*/
	function read_headers ()
	{
		$ret = false;
		$this->resp_headers = array ();
		$this->cookies = array ();
		$this->resp_status_code = '';
		$this->resp_status_msg = '';
		$this->resp_chunked = '';
		
		if ($this->fp)
		{
			// Normal HTTP connection. Read and parse headers. This will also set the
			// response code, digest parameters received etc.
			$response_header = '';
			while ($s = fgets ($this->fp, 1024) and (trim($s) != '')) $response_header.= $s;
			$this->parse_received_headers (trim($response_header));
			
			$ret = true;
			
			// If the response code is 401 (Unauthorized) and we have digest info, try to resend the request
			// This usually occurs when talking to an Exchange/IIS server, which from time to time has problems with 
			// re-using NONCE strings
			if ($this->auth_type=='Digest' and $this->resp_status_code == '401' and $this->digest_nonce)
			{
				// Flush (read) and discard whatever is left in the socket and close the connections
				if ($this->resp_content_length) fread($this->fp, $this->resp_content_length);
				$this->do_disconnect ();
				
				// Send the request again
				$this->set_default_headers ();
				$this->send_request ();
				
				$response_header = '';
				while ($s = fgets ($this->fp, 1024) and (trim($s) != '')) $response_header.= $s;
				$this->parse_received_headers (trim($response_header));
				
				$ret = true;
			}
		}
		
		return $ret;
	}
	
	
	/** Parse a 'Set-Cookie' header received from the server and appends the received cookies to the list 
	* in the current object. This is normally used from read_headers (). */
	function parse_resp_cookies ($header_line)
	{
		$header_line = preg_replace ('/^Set-Cookie\:\s*/', '', $header_line);
		$cookie_vals = preg_split ('/,\s*/', $header_line);
		foreach ($cookie_vals as $s)
		{
			list ($k, $v) = preg_split ('/\=\s*/', $s, 2);
			$this->cookies[$k] = $v;
		}
	}
	
	
	function get_resp_headers ($header_name, $match = '')
	{
		$ret = array ();
		for ($i=0; $i<count($this->resp_headers); $i++)
		{
			if ($header_name == $this->resp_headers[$i]['name'])
			{
				if (!$match) $ret[] = $this->resp_headers[$i]['value'];
				else
				{
					if (preg_match('/'.$match.'/', $this->resp_headers[$i]['value']))
					{
						$ret[] = $this->resp_headers[$i]['value'];
					}
				}
			}
		}
		return $ret;
	}
	
	function get_resp_headers_str ()
	{
		$ret = '';
		$ret = $this->resp_status."\r\n";
		for ($i=0; $i<count($this->resp_headers); $i++)
		{
			$ret.= $this->resp_headers[$i]['name'].': '.$this->resp_headers[$i]['value']."\r\n";
		}
		return $ret;
	}
	
	
	function set_default_headers ($keep_alive = false)
	{
		$this->headers = array (
			'Connection' => ($keep_alive ? 'Keep-Alive' : 'Close'),
			'User-Agent' => 'KeyOS',
			'Pragma' => 'no-cache',
			'Host' => $this->server,
			'Accept' => 'text/xml, */*',
			'Accept-Charset' => 'ISO-8859-1',
		);
		
		// Append extra headers requested by calling application
		foreach ($this->headers_extra as $k => $v) $this->headers[$k] = $v;
		
		if ($this->payload) $this->headers['Content-Length'] = strlen($this->payload);
		if ($this->content_type) $this->headers['Content-Type'] = $this->content_type;
		
		// Digest authentication: If we have digest authentication information, add them to the header too
		if ($this->auth_type=='Digest' and $this->digest_ha1)
		{
			$url = preg_replace ('/\?.*$/', '', $this->url);
			$counter = str_pad($this->digest_counter, 8, 0, STR_PAD_LEFT);
			
			if ($this->digest_algorithm == 'MD5-sess') $ha1 = md5($this->digest_ha1.':'.$this->digest_nonce.':'.$this->digest_cnonce);
			else $ha1 = $this->digest_ha1;
			
			if ($this->digest_qop == 'auth-int') $a2 = $this->method.':'.$url.':'.md5($this->payload);
			else $a2 = $this->method.':'.$url;
			
			$response = $ha1.':'.$this->digest_nonce.':'.$counter.':'.$this->digest_cnonce.':'.$this->digest_qop.':'.md5($a2);
			$response = md5($response);
			
			$auth = 'Digest username="'.$this->username.'", realm="'.$this->digest_realm.'", qop="'.$this->digest_qop.'", ';
			$auth.= 'algorithm="'.$this->digest_algorithm.'", uri="'.$url.'", ';
			$auth.= 'nonce="'.$this->digest_nonce.'", nc='.$counter.', cnonce="'.$this->digest_cnonce.'", response="'.$response.'"';
			$this->headers['Authorization'] = $auth;
			
			$this->digest_counter++;
		}
		
		// Basic authentication
		if ($this->auth_type=='Basic' and (($this->username and $this->password) or $this->basic_ident))
		{
			if ($this->username and $this->password) $auth = 'Basic '.base64_encode($this->username.':'.$this->password);
			else $auth = 'Basic '.$this->basic_ident;
			
			$this->headers['Authorization'] = $auth;
		}
		
		// Return the cookies, if we have any
		if (count($this->cookies) > 0)
		{
			$cookies_str = '';
			foreach ($this->cookies as $k=>$v) $cookies_str.= $k.'='.$v.' ; ';
			$cookies_str = preg_replace ('/; path=[^\s]+\s+/', '', $cookies_str);
			$cookies_str = preg_replace ('/;\s+$/', '', $cookies_str);
			$this->headers['Cookie'] = $cookies_str;
		}
	}
	
	
	/** Builds a string with the HTTP headers. This is used only for HTTP connections. For HTTPS connections
	* it returns an empty string, since the headers will be set in the CURL object by send_http_header()
	*/
	function build_http_header ()
	{
		$ret = $this->method.' '.$this->url.' HTTP/1.1'."\r\n";
		foreach ($this->headers as $k => $v) $ret.= $k.': '.$v."\r\n";
		$ret.= "\r\n";
		
		return $ret;
	}
	
	
	/** Sends or set the HTTP headers. If the connection uses HTTP, then the headers (built with build_http_header()) are written to the
	* connection socket. If the connection uses HTTPS, then the headers are directly loaded in the CURL object */
	function send_http_header ()
	{
		if ($this->fp) 
		{
			$this->resp_content_length = 0;
			fwrite ($this->fp, $this->build_http_header());
		}
	}
	
	
	/** Sends or sets the request body ($this->payload). For HTTP connections, this means writing the body to the
	* connection socket. For HTTPS connections this means setting setting the body in the CURL object (with CURLOPT_POSTFIELDS). */
	function send_request ()
	{
		if (!$this->fp) $this->do_connect ();
		if ($this->fp)
		{
			$this->send_http_header ();
			fwrite ($this->fp, $this->payload);
			
		}
	}
	
	
	/** Initializes the connection to the server */
	function do_connect ()
	{
		$server = ($this->protocol == 'HTTPS' ? 'ssl://'.$this->server : $this->server);
		$this->fp = @fsockopen ($server, $this->port, $this->last_conn_errno, $this->last_conn_errstr, $this->timeout);
		if ($this->fp)
		{
			$this->is_connected = true;
			stream_set_timeout($this->fp, $this->timeout);
		}
		else
		{
			$this->fp = null;
			$this->is_connected = false;
			$this->last_error = 'Failed connecting to '.$this->server;
		}

		return $this->is_connected;
	}

	
	/** Closes the connection to the remote server */
	function do_disconnect ()
	{
		if ($this->fp) @fclose ($this->fp);
		$this->fp = null;
		$this->is_connected = false;
	}
}


?>